<!DOCTYPE html>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../resources/webxr_util.js"></script>
<script src="../resources/webxr_test_asserts.js"></script>
<script src="../resources/webxr_test_constants.js"></script>
<script src="../resources/webxr_test_constants_fake_depth.js"></script>

<script>

const fakeDeviceInitParams = {
  supportedModes: ["immersive-ar"],
  views: VALID_VIEWS,
  supportedFeatures: ALL_FEATURES,
};

const TestStates = Object.freeze({
  "ShouldSucceedScheduleRAF": 1,
  "ShouldFailScheduleRAF": 2,
  "ShouldSucceedTestDone": 3,
});

const testFunctionGenerator = function(isCpuOptimized) {
  return (session, controller, t, sessionObjects) => {
    let state = TestStates.ShouldSucceedScheduleRAF;

    return session.requestReferenceSpace('viewer').then((viewerSpace) => {
      let done = false;

      const glBinding = new XRWebGLBinding(session, sessionObjects.gl);

      const rafCb = function(time, frame) {
        const pose = frame.getViewerPose(viewerSpace);
        for(const view of pose.views) {
          const depthInformation = isCpuOptimized ? frame.getDepthInformation(view)
                                                  : glBinding.getDepthInformation(view);

          if (state == TestStates.ShouldSucceedScheduleRAF
          || state == TestStates.ShouldSucceedTestDone) {
            t.step(() => {
              assert_not_equals(depthInformation, null);
            });
          } else {
            t.step(() => {
              assert_equals(depthInformation, null);
            });
          }
        }

        switch(state) {
          case TestStates.ShouldSucceedScheduleRAF:
            controller.clearDepthSensingData();
            state = TestStates.ShouldFailScheduleRAF;
            session.requestAnimationFrame(rafCb);
            break;
          case TestStates.ShouldFailScheduleRAF:
            controller.setDepthSensingData(depthSensingData);
            state = TestStates.ShouldSucceedTestDone;
            session.requestAnimationFrame(rafCb);
            break;
          case TestStates.ShouldSucceedTestDone:
            done = true;
            break;
        }
      };

      session.requestAnimationFrame(rafCb);

      return t.step_wait(() => done);
    });
  };
};

xr_session_promise_test("Ensures depth data is not available when cleared in the controller, `cpu-optimized`",
  testFunctionGenerator(/*isCpuOptimized=*/true),
  Object.assign({}, fakeDeviceInitParams, { depthSensingData }),
  'immersive-ar', {
    requiredFeatures: ['depth-sensing'],
    depthSensing: {
      usagePreference: ['cpu-optimized'],
      dataFormatPreference: ['luminance-alpha', 'float32'],
    }
  },
  /*properties=*/null, /*glcontextPropertiesParam=*/null, /*gllayerPropertiesParam=*/null,
  /*ignoreSessionCreationFailure=*/true);

xr_session_promise_test("Ensures depth data is not available when cleared in the controller, `gpu-optimized`",
  testFunctionGenerator(/*isCpuOptimized=*/false),
  Object.assign({}, fakeDeviceInitParams, { depthSensingData }),
  'immersive-ar', {
    requiredFeatures: ['depth-sensing'],
    depthSensing: {
      usagePreference: ['gpu-optimized'],
      dataFormatPreference: ['luminance-alpha', 'float32'],
    }
  },
  /*properties=*/null, /*glcontextPropertiesParam=*/null, /*gllayerPropertiesParam=*/null,
  /*ignoreSessionCreationFailure=*/true);

</script>
